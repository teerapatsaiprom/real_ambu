// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/ambu/app/ent/car"
	"github.com/ambu/app/ent/predicament"
	"github.com/ambu/app/ent/staff"
	"github.com/ambu/app/ent/statuscar"
	"github.com/ambu/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCar         = "Car"
	TypePredicament = "Predicament"
	TypeStaff       = "Staff"
	TypeStatuscar   = "Statuscar"
	TypeUser        = "User"
)

// CarMutation represents an operation that mutate the Cars
// nodes in the graph.
type CarMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	car_no                 *string
	clearedFields          map[string]struct{}
	car_predicament        map[int]struct{}
	removedcar_predicament map[int]struct{}
	done                   bool
	oldValue               func(context.Context) (*Car, error)
}

var _ ent.Mutation = (*CarMutation)(nil)

// carOption allows to manage the mutation configuration using functional options.
type carOption func(*CarMutation)

// newCarMutation creates new mutation for $n.Name.
func newCarMutation(c config, op Op, opts ...carOption) *CarMutation {
	m := &CarMutation{
		config:        c,
		op:            op,
		typ:           TypeCar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarID sets the id field of the mutation.
func withCarID(id int) carOption {
	return func(m *CarMutation) {
		var (
			err   error
			once  sync.Once
			value *Car
		)
		m.oldValue = func(ctx context.Context) (*Car, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Car.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCar sets the old Car of the mutation.
func withCar(node *Car) carOption {
	return func(m *CarMutation) {
		m.oldValue = func(context.Context) (*Car, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCarNo sets the car_no field.
func (m *CarMutation) SetCarNo(s string) {
	m.car_no = &s
}

// CarNo returns the car_no value in the mutation.
func (m *CarMutation) CarNo() (r string, exists bool) {
	v := m.car_no
	if v == nil {
		return
	}
	return *v, true
}

// OldCarNo returns the old car_no value of the Car.
// If the Car object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CarMutation) OldCarNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCarNo is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCarNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarNo: %w", err)
	}
	return oldValue.CarNo, nil
}

// ResetCarNo reset all changes of the "car_no" field.
func (m *CarMutation) ResetCarNo() {
	m.car_no = nil
}

// AddCarPredicamentIDs adds the car_predicament edge to Predicament by ids.
func (m *CarMutation) AddCarPredicamentIDs(ids ...int) {
	if m.car_predicament == nil {
		m.car_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.car_predicament[ids[i]] = struct{}{}
	}
}

// RemoveCarPredicamentIDs removes the car_predicament edge to Predicament by ids.
func (m *CarMutation) RemoveCarPredicamentIDs(ids ...int) {
	if m.removedcar_predicament == nil {
		m.removedcar_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.removedcar_predicament[ids[i]] = struct{}{}
	}
}

// RemovedCarPredicament returns the removed ids of car_predicament.
func (m *CarMutation) RemovedCarPredicamentIDs() (ids []int) {
	for id := range m.removedcar_predicament {
		ids = append(ids, id)
	}
	return
}

// CarPredicamentIDs returns the car_predicament ids in the mutation.
func (m *CarMutation) CarPredicamentIDs() (ids []int) {
	for id := range m.car_predicament {
		ids = append(ids, id)
	}
	return
}

// ResetCarPredicament reset all changes of the "car_predicament" edge.
func (m *CarMutation) ResetCarPredicament() {
	m.car_predicament = nil
	m.removedcar_predicament = nil
}

// Op returns the operation name.
func (m *CarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Car).
func (m *CarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CarMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.car_no != nil {
		fields = append(fields, car.FieldCarNo)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case car.FieldCarNo:
		return m.CarNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case car.FieldCarNo:
		return m.OldCarNo(ctx)
	}
	return nil, fmt.Errorf("unknown Car field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case car.FieldCarNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarNo(v)
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Car numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Car nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CarMutation) ResetField(name string) error {
	switch name {
	case car.FieldCarNo:
		m.ResetCarNo()
		return nil
	}
	return fmt.Errorf("unknown Car field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CarMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.car_predicament != nil {
		edges = append(edges, car.EdgeCarPredicament)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeCarPredicament:
		ids := make([]ent.Value, 0, len(m.car_predicament))
		for id := range m.car_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedcar_predicament != nil {
		edges = append(edges, car.EdgeCarPredicament)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case car.EdgeCarPredicament:
		ids := make([]ent.Value, 0, len(m.removedcar_predicament))
		for id := range m.removedcar_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CarMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CarMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Car unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CarMutation) ResetEdge(name string) error {
	switch name {
	case car.EdgeCarPredicament:
		m.ResetCarPredicament()
		return nil
	}
	return fmt.Errorf("unknown Car edge %s", name)
}

// PredicamentMutation represents an operation that mutate the Predicaments
// nodes in the graph.
type PredicamentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Added_Time       *time.Time
	clearedFields     map[string]struct{}
	_Car              *int
	cleared_Car       bool
	_Statuscar        *int
	cleared_Statuscar bool
	_Staff            *int
	cleared_Staff     bool
	_User             *int
	cleared_User      bool
	done              bool
	oldValue          func(context.Context) (*Predicament, error)
}

var _ ent.Mutation = (*PredicamentMutation)(nil)

// predicamentOption allows to manage the mutation configuration using functional options.
type predicamentOption func(*PredicamentMutation)

// newPredicamentMutation creates new mutation for $n.Name.
func newPredicamentMutation(c config, op Op, opts ...predicamentOption) *PredicamentMutation {
	m := &PredicamentMutation{
		config:        c,
		op:            op,
		typ:           TypePredicament,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPredicamentID sets the id field of the mutation.
func withPredicamentID(id int) predicamentOption {
	return func(m *PredicamentMutation) {
		var (
			err   error
			once  sync.Once
			value *Predicament
		)
		m.oldValue = func(ctx context.Context) (*Predicament, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Predicament.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPredicament sets the old Predicament of the mutation.
func withPredicament(node *Predicament) predicamentOption {
	return func(m *PredicamentMutation) {
		m.oldValue = func(context.Context) (*Predicament, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PredicamentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PredicamentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PredicamentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedTime sets the Added_Time field.
func (m *PredicamentMutation) SetAddedTime(t time.Time) {
	m._Added_Time = &t
}

// AddedTime returns the Added_Time value in the mutation.
func (m *PredicamentMutation) AddedTime() (r time.Time, exists bool) {
	v := m._Added_Time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old Added_Time value of the Predicament.
// If the Predicament object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PredicamentMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime reset all changes of the "Added_Time" field.
func (m *PredicamentMutation) ResetAddedTime() {
	m._Added_Time = nil
}

// SetCarID sets the Car edge to Car by id.
func (m *PredicamentMutation) SetCarID(id int) {
	m._Car = &id
}

// ClearCar clears the Car edge to Car.
func (m *PredicamentMutation) ClearCar() {
	m.cleared_Car = true
}

// CarCleared returns if the edge Car was cleared.
func (m *PredicamentMutation) CarCleared() bool {
	return m.cleared_Car
}

// CarID returns the Car id in the mutation.
func (m *PredicamentMutation) CarID() (id int, exists bool) {
	if m._Car != nil {
		return *m._Car, true
	}
	return
}

// CarIDs returns the Car ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CarID instead. It exists only for internal usage by the builders.
func (m *PredicamentMutation) CarIDs() (ids []int) {
	if id := m._Car; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCar reset all changes of the "Car" edge.
func (m *PredicamentMutation) ResetCar() {
	m._Car = nil
	m.cleared_Car = false
}

// SetStatuscarID sets the Statuscar edge to Statuscar by id.
func (m *PredicamentMutation) SetStatuscarID(id int) {
	m._Statuscar = &id
}

// ClearStatuscar clears the Statuscar edge to Statuscar.
func (m *PredicamentMutation) ClearStatuscar() {
	m.cleared_Statuscar = true
}

// StatuscarCleared returns if the edge Statuscar was cleared.
func (m *PredicamentMutation) StatuscarCleared() bool {
	return m.cleared_Statuscar
}

// StatuscarID returns the Statuscar id in the mutation.
func (m *PredicamentMutation) StatuscarID() (id int, exists bool) {
	if m._Statuscar != nil {
		return *m._Statuscar, true
	}
	return
}

// StatuscarIDs returns the Statuscar ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StatuscarID instead. It exists only for internal usage by the builders.
func (m *PredicamentMutation) StatuscarIDs() (ids []int) {
	if id := m._Statuscar; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStatuscar reset all changes of the "Statuscar" edge.
func (m *PredicamentMutation) ResetStatuscar() {
	m._Statuscar = nil
	m.cleared_Statuscar = false
}

// SetStaffID sets the Staff edge to Staff by id.
func (m *PredicamentMutation) SetStaffID(id int) {
	m._Staff = &id
}

// ClearStaff clears the Staff edge to Staff.
func (m *PredicamentMutation) ClearStaff() {
	m.cleared_Staff = true
}

// StaffCleared returns if the edge Staff was cleared.
func (m *PredicamentMutation) StaffCleared() bool {
	return m.cleared_Staff
}

// StaffID returns the Staff id in the mutation.
func (m *PredicamentMutation) StaffID() (id int, exists bool) {
	if m._Staff != nil {
		return *m._Staff, true
	}
	return
}

// StaffIDs returns the Staff ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// StaffID instead. It exists only for internal usage by the builders.
func (m *PredicamentMutation) StaffIDs() (ids []int) {
	if id := m._Staff; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStaff reset all changes of the "Staff" edge.
func (m *PredicamentMutation) ResetStaff() {
	m._Staff = nil
	m.cleared_Staff = false
}

// SetUserID sets the User edge to User by id.
func (m *PredicamentMutation) SetUserID(id int) {
	m._User = &id
}

// ClearUser clears the User edge to User.
func (m *PredicamentMutation) ClearUser() {
	m.cleared_User = true
}

// UserCleared returns if the edge User was cleared.
func (m *PredicamentMutation) UserCleared() bool {
	return m.cleared_User
}

// UserID returns the User id in the mutation.
func (m *PredicamentMutation) UserID() (id int, exists bool) {
	if m._User != nil {
		return *m._User, true
	}
	return
}

// UserIDs returns the User ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *PredicamentMutation) UserIDs() (ids []int) {
	if id := m._User; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "User" edge.
func (m *PredicamentMutation) ResetUser() {
	m._User = nil
	m.cleared_User = false
}

// Op returns the operation name.
func (m *PredicamentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Predicament).
func (m *PredicamentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PredicamentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Added_Time != nil {
		fields = append(fields, predicament.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PredicamentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case predicament.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PredicamentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case predicament.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Predicament field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PredicamentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case predicament.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Predicament field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PredicamentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PredicamentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PredicamentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Predicament numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PredicamentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PredicamentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PredicamentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Predicament nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PredicamentMutation) ResetField(name string) error {
	switch name {
	case predicament.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Predicament field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PredicamentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Car != nil {
		edges = append(edges, predicament.EdgeCar)
	}
	if m._Statuscar != nil {
		edges = append(edges, predicament.EdgeStatuscar)
	}
	if m._Staff != nil {
		edges = append(edges, predicament.EdgeStaff)
	}
	if m._User != nil {
		edges = append(edges, predicament.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PredicamentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case predicament.EdgeCar:
		if id := m._Car; id != nil {
			return []ent.Value{*id}
		}
	case predicament.EdgeStatuscar:
		if id := m._Statuscar; id != nil {
			return []ent.Value{*id}
		}
	case predicament.EdgeStaff:
		if id := m._Staff; id != nil {
			return []ent.Value{*id}
		}
	case predicament.EdgeUser:
		if id := m._User; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PredicamentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PredicamentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PredicamentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Car {
		edges = append(edges, predicament.EdgeCar)
	}
	if m.cleared_Statuscar {
		edges = append(edges, predicament.EdgeStatuscar)
	}
	if m.cleared_Staff {
		edges = append(edges, predicament.EdgeStaff)
	}
	if m.cleared_User {
		edges = append(edges, predicament.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PredicamentMutation) EdgeCleared(name string) bool {
	switch name {
	case predicament.EdgeCar:
		return m.cleared_Car
	case predicament.EdgeStatuscar:
		return m.cleared_Statuscar
	case predicament.EdgeStaff:
		return m.cleared_Staff
	case predicament.EdgeUser:
		return m.cleared_User
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PredicamentMutation) ClearEdge(name string) error {
	switch name {
	case predicament.EdgeCar:
		m.ClearCar()
		return nil
	case predicament.EdgeStatuscar:
		m.ClearStatuscar()
		return nil
	case predicament.EdgeStaff:
		m.ClearStaff()
		return nil
	case predicament.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Predicament unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PredicamentMutation) ResetEdge(name string) error {
	switch name {
	case predicament.EdgeCar:
		m.ResetCar()
		return nil
	case predicament.EdgeStatuscar:
		m.ResetStatuscar()
		return nil
	case predicament.EdgeStaff:
		m.ResetStaff()
		return nil
	case predicament.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Predicament edge %s", name)
}

// StaffMutation represents an operation that mutate the Staffs
// nodes in the graph.
type StaffMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	staff_email              *string
	staff_name               *string
	staff_password           *string
	clearedFields            map[string]struct{}
	staff_predicament        map[int]struct{}
	removedstaff_predicament map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Staff, error)
}

var _ ent.Mutation = (*StaffMutation)(nil)

// staffOption allows to manage the mutation configuration using functional options.
type staffOption func(*StaffMutation)

// newStaffMutation creates new mutation for $n.Name.
func newStaffMutation(c config, op Op, opts ...staffOption) *StaffMutation {
	m := &StaffMutation{
		config:        c,
		op:            op,
		typ:           TypeStaff,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStaffID sets the id field of the mutation.
func withStaffID(id int) staffOption {
	return func(m *StaffMutation) {
		var (
			err   error
			once  sync.Once
			value *Staff
		)
		m.oldValue = func(ctx context.Context) (*Staff, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Staff.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStaff sets the old Staff of the mutation.
func withStaff(node *Staff) staffOption {
	return func(m *StaffMutation) {
		m.oldValue = func(context.Context) (*Staff, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StaffMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StaffMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StaffMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStaffEmail sets the staff_email field.
func (m *StaffMutation) SetStaffEmail(s string) {
	m.staff_email = &s
}

// StaffEmail returns the staff_email value in the mutation.
func (m *StaffMutation) StaffEmail() (r string, exists bool) {
	v := m.staff_email
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffEmail returns the old staff_email value of the Staff.
// If the Staff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaffMutation) OldStaffEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaffEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaffEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffEmail: %w", err)
	}
	return oldValue.StaffEmail, nil
}

// ResetStaffEmail reset all changes of the "staff_email" field.
func (m *StaffMutation) ResetStaffEmail() {
	m.staff_email = nil
}

// SetStaffName sets the staff_name field.
func (m *StaffMutation) SetStaffName(s string) {
	m.staff_name = &s
}

// StaffName returns the staff_name value in the mutation.
func (m *StaffMutation) StaffName() (r string, exists bool) {
	v := m.staff_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffName returns the old staff_name value of the Staff.
// If the Staff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaffMutation) OldStaffName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaffName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaffName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffName: %w", err)
	}
	return oldValue.StaffName, nil
}

// ResetStaffName reset all changes of the "staff_name" field.
func (m *StaffMutation) ResetStaffName() {
	m.staff_name = nil
}

// SetStaffPassword sets the staff_password field.
func (m *StaffMutation) SetStaffPassword(s string) {
	m.staff_password = &s
}

// StaffPassword returns the staff_password value in the mutation.
func (m *StaffMutation) StaffPassword() (r string, exists bool) {
	v := m.staff_password
	if v == nil {
		return
	}
	return *v, true
}

// OldStaffPassword returns the old staff_password value of the Staff.
// If the Staff object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StaffMutation) OldStaffPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStaffPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStaffPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStaffPassword: %w", err)
	}
	return oldValue.StaffPassword, nil
}

// ResetStaffPassword reset all changes of the "staff_password" field.
func (m *StaffMutation) ResetStaffPassword() {
	m.staff_password = nil
}

// AddStaffPredicamentIDs adds the staff_predicament edge to Predicament by ids.
func (m *StaffMutation) AddStaffPredicamentIDs(ids ...int) {
	if m.staff_predicament == nil {
		m.staff_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.staff_predicament[ids[i]] = struct{}{}
	}
}

// RemoveStaffPredicamentIDs removes the staff_predicament edge to Predicament by ids.
func (m *StaffMutation) RemoveStaffPredicamentIDs(ids ...int) {
	if m.removedstaff_predicament == nil {
		m.removedstaff_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstaff_predicament[ids[i]] = struct{}{}
	}
}

// RemovedStaffPredicament returns the removed ids of staff_predicament.
func (m *StaffMutation) RemovedStaffPredicamentIDs() (ids []int) {
	for id := range m.removedstaff_predicament {
		ids = append(ids, id)
	}
	return
}

// StaffPredicamentIDs returns the staff_predicament ids in the mutation.
func (m *StaffMutation) StaffPredicamentIDs() (ids []int) {
	for id := range m.staff_predicament {
		ids = append(ids, id)
	}
	return
}

// ResetStaffPredicament reset all changes of the "staff_predicament" edge.
func (m *StaffMutation) ResetStaffPredicament() {
	m.staff_predicament = nil
	m.removedstaff_predicament = nil
}

// Op returns the operation name.
func (m *StaffMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Staff).
func (m *StaffMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StaffMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.staff_email != nil {
		fields = append(fields, staff.FieldStaffEmail)
	}
	if m.staff_name != nil {
		fields = append(fields, staff.FieldStaffName)
	}
	if m.staff_password != nil {
		fields = append(fields, staff.FieldStaffPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StaffMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case staff.FieldStaffEmail:
		return m.StaffEmail()
	case staff.FieldStaffName:
		return m.StaffName()
	case staff.FieldStaffPassword:
		return m.StaffPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StaffMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case staff.FieldStaffEmail:
		return m.OldStaffEmail(ctx)
	case staff.FieldStaffName:
		return m.OldStaffName(ctx)
	case staff.FieldStaffPassword:
		return m.OldStaffPassword(ctx)
	}
	return nil, fmt.Errorf("unknown Staff field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaffMutation) SetField(name string, value ent.Value) error {
	switch name {
	case staff.FieldStaffEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffEmail(v)
		return nil
	case staff.FieldStaffName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffName(v)
		return nil
	case staff.FieldStaffPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStaffPassword(v)
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StaffMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StaffMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StaffMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Staff numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StaffMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StaffMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StaffMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Staff nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StaffMutation) ResetField(name string) error {
	switch name {
	case staff.FieldStaffEmail:
		m.ResetStaffEmail()
		return nil
	case staff.FieldStaffName:
		m.ResetStaffName()
		return nil
	case staff.FieldStaffPassword:
		m.ResetStaffPassword()
		return nil
	}
	return fmt.Errorf("unknown Staff field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StaffMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.staff_predicament != nil {
		edges = append(edges, staff.EdgeStaffPredicament)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StaffMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeStaffPredicament:
		ids := make([]ent.Value, 0, len(m.staff_predicament))
		for id := range m.staff_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StaffMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstaff_predicament != nil {
		edges = append(edges, staff.EdgeStaffPredicament)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StaffMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case staff.EdgeStaffPredicament:
		ids := make([]ent.Value, 0, len(m.removedstaff_predicament))
		for id := range m.removedstaff_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StaffMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StaffMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StaffMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Staff unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StaffMutation) ResetEdge(name string) error {
	switch name {
	case staff.EdgeStaffPredicament:
		m.ResetStaffPredicament()
		return nil
	}
	return fmt.Errorf("unknown Staff edge %s", name)
}

// StatuscarMutation represents an operation that mutate the Statuscars
// nodes in the graph.
type StatuscarMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	status_detail                *string
	clearedFields                map[string]struct{}
	statuscar_predicament        map[int]struct{}
	removedstatuscar_predicament map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Statuscar, error)
}

var _ ent.Mutation = (*StatuscarMutation)(nil)

// statuscarOption allows to manage the mutation configuration using functional options.
type statuscarOption func(*StatuscarMutation)

// newStatuscarMutation creates new mutation for $n.Name.
func newStatuscarMutation(c config, op Op, opts ...statuscarOption) *StatuscarMutation {
	m := &StatuscarMutation{
		config:        c,
		op:            op,
		typ:           TypeStatuscar,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStatuscarID sets the id field of the mutation.
func withStatuscarID(id int) statuscarOption {
	return func(m *StatuscarMutation) {
		var (
			err   error
			once  sync.Once
			value *Statuscar
		)
		m.oldValue = func(ctx context.Context) (*Statuscar, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Statuscar.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStatuscar sets the old Statuscar of the mutation.
func withStatuscar(node *Statuscar) statuscarOption {
	return func(m *StatuscarMutation) {
		m.oldValue = func(context.Context) (*Statuscar, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StatuscarMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StatuscarMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *StatuscarMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetStatusDetail sets the status_detail field.
func (m *StatuscarMutation) SetStatusDetail(s string) {
	m.status_detail = &s
}

// StatusDetail returns the status_detail value in the mutation.
func (m *StatuscarMutation) StatusDetail() (r string, exists bool) {
	v := m.status_detail
	if v == nil {
		return
	}
	return *v, true
}

// OldStatusDetail returns the old status_detail value of the Statuscar.
// If the Statuscar object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *StatuscarMutation) OldStatusDetail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatusDetail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatusDetail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatusDetail: %w", err)
	}
	return oldValue.StatusDetail, nil
}

// ResetStatusDetail reset all changes of the "status_detail" field.
func (m *StatuscarMutation) ResetStatusDetail() {
	m.status_detail = nil
}

// AddStatuscarPredicamentIDs adds the statuscar_predicament edge to Predicament by ids.
func (m *StatuscarMutation) AddStatuscarPredicamentIDs(ids ...int) {
	if m.statuscar_predicament == nil {
		m.statuscar_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.statuscar_predicament[ids[i]] = struct{}{}
	}
}

// RemoveStatuscarPredicamentIDs removes the statuscar_predicament edge to Predicament by ids.
func (m *StatuscarMutation) RemoveStatuscarPredicamentIDs(ids ...int) {
	if m.removedstatuscar_predicament == nil {
		m.removedstatuscar_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.removedstatuscar_predicament[ids[i]] = struct{}{}
	}
}

// RemovedStatuscarPredicament returns the removed ids of statuscar_predicament.
func (m *StatuscarMutation) RemovedStatuscarPredicamentIDs() (ids []int) {
	for id := range m.removedstatuscar_predicament {
		ids = append(ids, id)
	}
	return
}

// StatuscarPredicamentIDs returns the statuscar_predicament ids in the mutation.
func (m *StatuscarMutation) StatuscarPredicamentIDs() (ids []int) {
	for id := range m.statuscar_predicament {
		ids = append(ids, id)
	}
	return
}

// ResetStatuscarPredicament reset all changes of the "statuscar_predicament" edge.
func (m *StatuscarMutation) ResetStatuscarPredicament() {
	m.statuscar_predicament = nil
	m.removedstatuscar_predicament = nil
}

// Op returns the operation name.
func (m *StatuscarMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Statuscar).
func (m *StatuscarMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *StatuscarMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.status_detail != nil {
		fields = append(fields, statuscar.FieldStatusDetail)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *StatuscarMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case statuscar.FieldStatusDetail:
		return m.StatusDetail()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *StatuscarMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case statuscar.FieldStatusDetail:
		return m.OldStatusDetail(ctx)
	}
	return nil, fmt.Errorf("unknown Statuscar field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatuscarMutation) SetField(name string, value ent.Value) error {
	switch name {
	case statuscar.FieldStatusDetail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatusDetail(v)
		return nil
	}
	return fmt.Errorf("unknown Statuscar field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *StatuscarMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *StatuscarMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *StatuscarMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Statuscar numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *StatuscarMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *StatuscarMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *StatuscarMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Statuscar nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *StatuscarMutation) ResetField(name string) error {
	switch name {
	case statuscar.FieldStatusDetail:
		m.ResetStatusDetail()
		return nil
	}
	return fmt.Errorf("unknown Statuscar field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *StatuscarMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.statuscar_predicament != nil {
		edges = append(edges, statuscar.EdgeStatuscarPredicament)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *StatuscarMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case statuscar.EdgeStatuscarPredicament:
		ids := make([]ent.Value, 0, len(m.statuscar_predicament))
		for id := range m.statuscar_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *StatuscarMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedstatuscar_predicament != nil {
		edges = append(edges, statuscar.EdgeStatuscarPredicament)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *StatuscarMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case statuscar.EdgeStatuscarPredicament:
		ids := make([]ent.Value, 0, len(m.removedstatuscar_predicament))
		for id := range m.removedstatuscar_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *StatuscarMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *StatuscarMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *StatuscarMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Statuscar unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *StatuscarMutation) ResetEdge(name string) error {
	switch name {
	case statuscar.EdgeStatuscarPredicament:
		m.ResetStatuscarPredicament()
		return nil
	}
	return fmt.Errorf("unknown Statuscar edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	user_email              *string
	user_name               *string
	user_password           *string
	clearedFields           map[string]struct{}
	user_predicament        map[int]struct{}
	removeduser_predicament map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUserEmail sets the user_email field.
func (m *UserMutation) SetUserEmail(s string) {
	m.user_email = &s
}

// UserEmail returns the user_email value in the mutation.
func (m *UserMutation) UserEmail() (r string, exists bool) {
	v := m.user_email
	if v == nil {
		return
	}
	return *v, true
}

// OldUserEmail returns the old user_email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUserEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserEmail: %w", err)
	}
	return oldValue.UserEmail, nil
}

// ResetUserEmail reset all changes of the "user_email" field.
func (m *UserMutation) ResetUserEmail() {
	m.user_email = nil
}

// SetUserName sets the user_name field.
func (m *UserMutation) SetUserName(s string) {
	m.user_name = &s
}

// UserName returns the user_name value in the mutation.
func (m *UserMutation) UserName() (r string, exists bool) {
	v := m.user_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUserName returns the old user_name value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUserName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserName: %w", err)
	}
	return oldValue.UserName, nil
}

// ResetUserName reset all changes of the "user_name" field.
func (m *UserMutation) ResetUserName() {
	m.user_name = nil
}

// SetUserPassword sets the user_password field.
func (m *UserMutation) SetUserPassword(s string) {
	m.user_password = &s
}

// UserPassword returns the user_password value in the mutation.
func (m *UserMutation) UserPassword() (r string, exists bool) {
	v := m.user_password
	if v == nil {
		return
	}
	return *v, true
}

// OldUserPassword returns the old user_password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldUserPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUserPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUserPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserPassword: %w", err)
	}
	return oldValue.UserPassword, nil
}

// ResetUserPassword reset all changes of the "user_password" field.
func (m *UserMutation) ResetUserPassword() {
	m.user_password = nil
}

// AddUserPredicamentIDs adds the user_predicament edge to Predicament by ids.
func (m *UserMutation) AddUserPredicamentIDs(ids ...int) {
	if m.user_predicament == nil {
		m.user_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.user_predicament[ids[i]] = struct{}{}
	}
}

// RemoveUserPredicamentIDs removes the user_predicament edge to Predicament by ids.
func (m *UserMutation) RemoveUserPredicamentIDs(ids ...int) {
	if m.removeduser_predicament == nil {
		m.removeduser_predicament = make(map[int]struct{})
	}
	for i := range ids {
		m.removeduser_predicament[ids[i]] = struct{}{}
	}
}

// RemovedUserPredicament returns the removed ids of user_predicament.
func (m *UserMutation) RemovedUserPredicamentIDs() (ids []int) {
	for id := range m.removeduser_predicament {
		ids = append(ids, id)
	}
	return
}

// UserPredicamentIDs returns the user_predicament ids in the mutation.
func (m *UserMutation) UserPredicamentIDs() (ids []int) {
	for id := range m.user_predicament {
		ids = append(ids, id)
	}
	return
}

// ResetUserPredicament reset all changes of the "user_predicament" edge.
func (m *UserMutation) ResetUserPredicament() {
	m.user_predicament = nil
	m.removeduser_predicament = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.user_email != nil {
		fields = append(fields, user.FieldUserEmail)
	}
	if m.user_name != nil {
		fields = append(fields, user.FieldUserName)
	}
	if m.user_password != nil {
		fields = append(fields, user.FieldUserPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUserEmail:
		return m.UserEmail()
	case user.FieldUserName:
		return m.UserName()
	case user.FieldUserPassword:
		return m.UserPassword()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUserEmail:
		return m.OldUserEmail(ctx)
	case user.FieldUserName:
		return m.OldUserName(ctx)
	case user.FieldUserPassword:
		return m.OldUserPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUserEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserEmail(v)
		return nil
	case user.FieldUserName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserName(v)
		return nil
	case user.FieldUserPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUserEmail:
		m.ResetUserEmail()
		return nil
	case user.FieldUserName:
		m.ResetUserName()
		return nil
	case user.FieldUserPassword:
		m.ResetUserPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user_predicament != nil {
		edges = append(edges, user.EdgeUserPredicament)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserPredicament:
		ids := make([]ent.Value, 0, len(m.user_predicament))
		for id := range m.user_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeduser_predicament != nil {
		edges = append(edges, user.EdgeUserPredicament)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserPredicament:
		ids := make([]ent.Value, 0, len(m.removeduser_predicament))
		for id := range m.removeduser_predicament {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserPredicament:
		m.ResetUserPredicament()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
